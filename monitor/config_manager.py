#!/usr/bin/env python3
import os
import json
import imaplib
import configparser
import re
import logging
import requests
from typing import Dict, Optional, List, Tuple
from datetime import datetime

# Configurar logging
os.makedirs('logs', exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/config_manager.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Configura√ß√£o dos servidores IMAP dispon√≠veis
IMAP_SERVERS = {
    'megasec': {
        'name': 'Megasec Email',
        'server': 'mail.megasec.com.br',  # Corrigido para o servidor correto conforme documenta√ß√£o
        'port': 993,
        'domain': 'megasec.com.br',
        'instructions': 'Use seu email @megasec.com.br e senha normal'
    },
    'gmail': {
        'name': 'Gmail',
        'server': 'imap.gmail.com',
        'port': 993,
        'domain': 'gmail.com',
        'instructions': '''Para Gmail, voc√™ precisa:
1. Ativar verifica√ß√£o em 2 etapas
2. Criar uma Senha de App em: https://myaccount.google.com/security
3. Usar a Senha de App gerada (n√£o sua senha normal)'''
    },
    'outlook': {
        'name': 'Outlook/Hotmail',
        'server': 'outlook.office365.com',
        'port': 993,
        'domain': 'outlook.com',
        'instructions': 'Use seu email Outlook/Hotmail e senha normal'
    },
    'yahoo': {
        'name': 'Yahoo Mail',
        'server': 'imap.mail.yahoo.com',
        'port': 993,
        'domain': 'yahoo.com',
        'instructions': '''Para Yahoo Mail, voc√™ precisa:
1. Ativar verifica√ß√£o em 2 etapas
2. Gerar uma senha de app
3. Usar a senha de app gerada (n√£o sua senha normal)'''
    }
}

def detect_server_from_email(email: str) -> Optional[Dict]:
    """Detecta o servidor IMAP baseado no dom√≠nio do e-mail"""
    domain = email.split('@')[-1].lower()
    for server in IMAP_SERVERS.values():
        if server['domain'] in domain:
            return server
    return None

def is_valid_email(email: str) -> bool:
    """Valida o formato do endere√ßo de email"""
    # Express√£o regular para valida√ß√£o b√°sica de email
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    return bool(re.match(pattern, email))

def is_valid_chat_id(chat_id: str) -> bool:
    """Valida o formato do chat_id do Telegram"""
    # Chat IDs do Telegram podem ser num√©ricos positivos ou negativos
    try:
        int(chat_id)
        return True
    except ValueError:
        return False

def load_config() -> configparser.ConfigParser:
    """Carrega a configura√ß√£o do arquivo config.ini"""
    config = configparser.ConfigParser()
    if os.path.exists('config.ini'):
        config.read('config.ini')
        logger.info("Arquivo de configura√ß√£o carregado com sucesso.")
    else:
        # Configura√ß√£o padr√£o apenas para a se√ß√£o TELEGRAM
        config['TELEGRAM'] = {}
        logger.info("Arquivo de configura√ß√£o n√£o encontrado. Criando novo arquivo.")
        save_config(config)
    return config

def save_config(config: configparser.ConfigParser):
    """Salva a configura√ß√£o no arquivo config.ini"""
    with open('config.ini', 'w') as f:
        config.write(f)
    logger.info("Configura√ß√£o salva com sucesso.")

def update_env_file(config: configparser.ConfigParser):
    """Atualiza o arquivo .env com as configura√ß√µes atuais"""
    email_configs = {}
    
    for section in config.sections():
        if section.startswith('IMAP_'):
            # Ignoramos se√ß√µes especiais como IMAP_PRIMARY e IMAP_SECONDARY
            # para o arquivo .env, pois s√£o tratadas pelo c√≥digo Python diretamente
            if section in ['IMAP_PRIMARY', 'IMAP_SECONDARY']:
                continue
                
            # Para se√ß√µes como IMAP_user@example.com
            email = section.replace('IMAP_', '')
            if 'username' in config[section]:
                email_config = {
                    'server': config[section]['server'],
                    'port': int(config[section]['port']),
                    'username': config[section]['username'],
                    'password': config[section]['password'],
                    'is_active': config[section].getboolean('is_active', True),
                    'telegram_chat_id': config[section].get('telegram_chat_id', '')
                }
                
                # Adiciona token espec√≠fico se existir
                if 'telegram_token' in config[section]:
                    email_config['telegram_token'] = config[section]['telegram_token']
                    
                email_configs[email] = email_config
    
    # Configura√ß√µes globais do Telegram
    telegram_token = config['TELEGRAM'].get('token', '')
    telegram_chat_id = config['TELEGRAM'].get('chat_id', '')
    
    env_content = f"""# Configuracao do Telegram Bot
TELEGRAM_TOKEN={telegram_token}
TELEGRAM_CHAT_ID={telegram_chat_id}

# Configuracoes de monitoramento (formato JSON)
MONITORED_EMAILS={json.dumps(email_configs)}
"""
    
    with open('.env', 'w', encoding='utf-8') as f:
        f.write(env_content)
    logger.info("Arquivo .env atualizado com sucesso.")

def escape_markdown(text: str) -> str:
    """Escapa caracteres especiais do Markdown para formata√ß√£o correta no Telegram"""
    if not text:
        return ""
    special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
    for char in special_chars:
        text = text.replace(char, '\\' + char)
    return text

def send_telegram_notification(config: configparser.ConfigParser, message: str, chat_id: str = None, token: str = None) -> bool:
    """Envia notifica√ß√£o via Telegram usando as configura√ß√µes fornecidas ou as padr√µes do arquivo config.ini"""
    if 'TELEGRAM' not in config:
        logger.error("Configura√ß√£o do Telegram n√£o encontrada!")
        return False
    
    # Usa os par√¢metros fornecidos ou os valores padr√£o do config
    if not token:
        token = config['TELEGRAM'].get('token', '')
    if not chat_id:
        chat_id = config['TELEGRAM'].get('chat_id', '')
    
    if not token or not chat_id:
        logger.error("Token ou Chat ID do Telegram ausentes!")
        return False
    
    url = f"https://api.telegram.org/bot{token}/sendMessage"
    try:
        response = requests.post(url, json={
            'chat_id': chat_id,
            'text': message,
            'parse_mode': 'MarkdownV2',
            'disable_web_page_preview': True
        }, timeout=10)
        
        if response.status_code == 200:
            logger.info(f"Notifica√ß√£o enviada com sucesso para chat_id {chat_id}")
            return True
        else:
            logger.error(f"Erro ao enviar notifica√ß√£o: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        logger.error(f"Exce√ß√£o ao enviar notifica√ß√£o: {e}")
        return False

def send_system_startup_notification(config: configparser.ConfigParser) -> bool:
    """
    Envia notifica√ß√£o de inicializa√ß√£o do sistema para todos os destinat√°rios configurados.
    Para o chat ID global, mostra todas as contas monitoradas.
    Para chat IDs espec√≠ficos (com tokens personalizados), mostra apenas as contas associadas a eles.
    """
    current_time = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
    base_message = (
        "üü¢ *WegNots Monitor Iniciado*\n\n"
        f"‚è∞ {escape_markdown(current_time)}\n"
        "‚úÖ Sistema de monitoramento iniciado com sucesso\\.\n"
        "‚úâÔ∏è Monitorando e\\-mails\\.\\.\\."
    )
    
    # Configura√ß√µes globais
    global_token = config['TELEGRAM'].get('token', '')
    global_chat_id = config['TELEGRAM'].get('chat_id', '')
    
    # Encontra todas as contas de email ativas
    active_accounts = []
    for section in config.sections():
        if section.startswith('IMAP_') and config[section].getboolean('is_active', True):
            if 'username' in config[section]:
                active_accounts.append(config[section]['username'])
    
    # 1. Enviar notifica√ß√£o para o chat ID global com todas as contas
    global_message = base_message
    if active_accounts:
        global_message += f"\n\nüì® Contas monitoradas: {len(active_accounts)}"
        for i, account in enumerate(active_accounts, 1):
            global_message += f"\n   {i}\\. {escape_markdown(account)}"
    
    global_success = False
    if global_token and global_chat_id:
        global_success = send_telegram_notification(config, global_message)
    
    # 2. Enviar notifica√ß√µes personalizadas para cada email com configura√ß√µes espec√≠ficas
    accounts_with_specific_settings = {}
    
    # Agrupar por destinos espec√≠ficos (combina√ß√µes √∫nicas de chat_id e token)
    for section in config.sections():
        if not section.startswith('IMAP_') or not config[section].getboolean('is_active', True):
            continue
            
        if 'username' not in config[section]:
            continue
            
        username = config[section]['username']
        
        # Obter chat_id e token (espec√≠fico ou global)
        specific_chat_id = config[section].get('telegram_chat_id', '')
        specific_token = config[section].get('telegram_token', '')
        
        # Se n√£o tiver chat_id espec√≠fico, use o global
        chat_id_to_use = specific_chat_id or global_chat_id
        # Se n√£o tiver token espec√≠fico, use o global
        token_to_use = specific_token or global_token
        
        # Apenas prossegue se ambos estiverem dispon√≠veis (seja espec√≠fico ou global)
        if not chat_id_to_use or not token_to_use:
            continue
        
        # Cria uma chave √∫nica para este destino
        destination_key = (chat_id_to_use, token_to_use)
        
        # Adiciona o email √† lista deste destino espec√≠fico
        if destination_key not in accounts_with_specific_settings:
            accounts_with_specific_settings[destination_key] = []
            
        accounts_with_specific_settings[destination_key].append(username)
    
    # Envia notifica√ß√µes personalizadas
    specific_success = True
    for (chat_id, token), accounts in accounts_with_specific_settings.items():
        if not accounts:
            continue
            
        specific_message = base_message
        specific_message += f"\n\nüì® Contas monitoradas: {len(accounts)}"
        for i, account in enumerate(accounts, 1):
            specific_message += f"\n   {i}\\. {escape_markdown(account)}"
            
        # N√£o enviamos para o chat_id global se j√° foi enviado
        if chat_id == global_chat_id and token == global_token and global_success:
            continue
            
        success = send_telegram_notification(config, specific_message, chat_id, token)
        specific_success = specific_success and success
        
    # Retorna True se pelo menos uma notifica√ß√£o foi enviada com sucesso
    return global_success or specific_success

def send_system_shutdown_notification(config: configparser.ConfigParser) -> bool:
    """
    Envia notifica√ß√£o de encerramento do sistema para todos os destinat√°rios configurados.
    Para o chat ID global, mostra uma mensagem padr√£o de encerramento.
    Para chat IDs espec√≠ficos (com tokens personalizados), mostra uma mensagem personalizada 
    indicando quais contas espec√≠ficas est√£o sendo encerradas.
    """
    current_time = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
    base_message = (
        "üî¥ *WegNots Monitor Encerrado*\n\n"
        f"‚è∞ {escape_markdown(current_time)}\n"
        "‚úÖ Sistema encerrado de forma segura\\.\n"
        "üîî Monitoramento interrompido\\."
    )
    
    # Configura√ß√µes globais
    global_token = config['TELEGRAM'].get('token', '')
    global_chat_id = config['TELEGRAM'].get('chat_id', '')
    
    # 1. Enviar notifica√ß√£o para o chat ID global
    global_success = False
    if global_token and global_chat_id:
        global_success = send_telegram_notification(config, base_message)
    
    # 2. Enviar notifica√ß√µes personalizadas para cada email com configura√ß√µes espec√≠ficas
    accounts_with_specific_settings = {}
    
    # Agrupar por destinos espec√≠ficos (combina√ß√µes √∫nicas de chat_id e token)
    for section in config.sections():
        if not section.startswith('IMAP_') or not config[section].getboolean('is_active', True):
            continue
            
        if 'username' not in config[section]:
            continue
            
        username = config[section]['username']
        
        # Obter chat_id e token (espec√≠fico ou global)
        specific_chat_id = config[section].get('telegram_chat_id', '')
        specific_token = config[section].get('telegram_token', '')
        
        # Se n√£o tiver chat_id espec√≠fico, use o global
        chat_id_to_use = specific_chat_id or global_chat_id
        # Se n√£o tiver token espec√≠fico, use o global
        token_to_use = specific_token or global_token
        
        # Apenas prossegue se ambos estiverem dispon√≠veis (seja espec√≠fico ou global)
        if not chat_id_to_use or not token_to_use:
            continue
        
        # Cria uma chave √∫nica para este destino
        destination_key = (chat_id_to_use, token_to_use)
        
        # Adiciona o email √† lista deste destino espec√≠fico
        if destination_key not in accounts_with_specific_settings:
            accounts_with_specific_settings[destination_key] = []
            
        accounts_with_specific_settings[destination_key].append(username)
    
    # Envia notifica√ß√µes personalizadas
    specific_success = True
    for (chat_id, token), accounts in accounts_with_specific_settings.items():
        if not accounts:
            continue
            
        specific_message = base_message
        
        # Adiciona informa√ß√£o sobre as contas que estavam sendo monitoradas
        if len(accounts) > 1:
            specific_message += f"\n\nüì® O monitoramento das seguintes contas foi encerrado:"
            for i, account in enumerate(accounts, 1):
                specific_message += f"\n   {i}\\. {escape_markdown(account)}"
        else:
            specific_message += f"\n\nüì® O monitoramento da conta {escape_markdown(accounts[0])} foi encerrado\\."
        
        # N√£o enviamos para o chat_id global se j√° foi enviado
        if chat_id == global_chat_id and token == global_token and global_success:
            continue
            
        success = send_telegram_notification(config, specific_message, chat_id, token)
        specific_success = specific_success and success
        
    # Retorna True se pelo menos uma notifica√ß√£o foi enviada com sucesso
    return global_success or specific_success

def test_email_connection(server: str, port: int, username: str, password: str) -> Tuple[bool, str]:
    """Testa a conex√£o com o servidor IMAP, retornando sucesso e mensagem de erro detalhada"""
    try:
        print(f"Conectando a {server}:{port}...")
        mail = imaplib.IMAP4_SSL(server, port)
        print("Autenticando...")
        mail.login(username, password)
        print("‚úÖ Conex√£o estabelecida!")
        mail.logout()
        return True, "Conex√£o estabelecida com sucesso."
    except imaplib.IMAP4.error as e:
        error_msg = f"Erro de autentica√ß√£o IMAP: {str(e)}"
        print(f"‚ùå {error_msg}")
        logger.error(error_msg)
        return False, error_msg
    except ConnectionRefusedError:
        error_msg = f"Conex√£o recusada pelo servidor {server}:{port}"
        print(f"‚ùå {error_msg}")
        logger.error(error_msg)
        return False, error_msg
    except TimeoutError:
        error_msg = f"Tempo limite excedido ao conectar a {server}:{port}"
        print(f"‚ùå {error_msg}")
        logger.error(error_msg)
        return False, error_msg
    except Exception as e:
        error_msg = f"Erro ao testar conex√£o: {str(e)}"
        print(f"‚ùå {error_msg}")
        logger.error(error_msg)
        return False, error_msg

def list_monitored_emails(config: configparser.ConfigParser):
    """Lista todos os e-mails monitorados"""
    print("\nE-mails monitorados:")
    print("-" * 60)
    found = False
    
    # Primeiro, tente encontrar as contas no formato IMAP_PRIMARY
    special_accounts = []
    for section in config.sections():
        if section in ['IMAP_PRIMARY', 'IMAP_SECONDARY'] and 'username' in config[section]:
            found = True
            email = config[section]['username']
            server = config[section]['server']
            special_accounts.append(section)
            print(f"üìß {email} ({section})")
            print(f"   Servidor: {server}")
            print(f"   Porta: {config[section]['port']}")
            print(f"   Ativo: {config[section].getboolean('is_active', True)}")
            print(f"   Chat ID: {config[section].get('telegram_chat_id', 'n√£o configurado')}")
            
            # Verifica se h√° token espec√≠fico
            if 'telegram_token' in config[section]:
                token = config[section]['telegram_token']
                masked_token = "‚Ä¢‚Ä¢‚Ä¢‚Ä¢" + token[-4:] if token else "n√£o configurado"
                print(f"   Token espec√≠fico: {masked_token}")
            else:
                print(f"   Token: Global")
                
            print("-" * 60)
    
    # Depois, procure outras contas no formato IMAP_email@example.com
    for section in config.sections():
        if section.startswith('IMAP_') and section not in special_accounts:
            found = True
            email = section.replace('IMAP_', '')
            if 'username' in config[section]:
                email = config[section]['username']
            server = config[section]['server']
            print(f"üìß {email}")
            print(f"   Servidor: {server}")
            print(f"   Porta: {config[section]['port']}")
            print(f"   Ativo: {config[section].getboolean('is_active', True)}")
            print(f"   Chat ID: {config[section].get('telegram_chat_id', 'n√£o configurado')}")
            
            # Verifica se h√° token espec√≠fico
            if 'telegram_token' in config[section]:
                token = config[section]['telegram_token']
                masked_token = "‚Ä¢‚Ä¢‚Ä¢‚Ä¢" + token[-4:] if token else "n√£o configurado"
                print(f"   Token espec√≠fico: {masked_token}")
            else:
                print(f"   Token: Global")
                
            print("-" * 60)
    
    if not found:
        print("Nenhum e-mail configurado!")

def choose_imap_server() -> Optional[Dict]:
    """Permite ao usu√°rio escolher um servidor IMAP"""
    print("\nServidores IMAP dispon√≠veis:")
    print("-" * 60)
    
    # Lista servidores dispon√≠veis
    for i, (key, server) in enumerate(IMAP_SERVERS.items(), 1):
        print(f"{i}. {server['name']}")
        print(f"   Servidor: {server['server']}:{server['port']}")
    
    try:
        choice = int(input("\nEscolha o servidor (0 para cancelar): "))
        if choice == 0:
            return None
        
        if 1 <= choice <= len(IMAP_SERVERS):
            server_key = list(IMAP_SERVERS.keys())[choice - 1]
            server = IMAP_SERVERS[server_key]
            
            # Mostra instru√ß√µes espec√≠ficas
            print("\nInstru√ß√µes importantes:")
            print("-" * 60)
            print(server['instructions'])
            print("-" * 60)
            
            return server
        else:
            print("Op√ß√£o inv√°lida!")
            return None
    except ValueError:
        print("Entrada inv√°lida!")
        return None

def add_email(config: configparser.ConfigParser):
    """Adiciona um novo e-mail para monitoramento"""
    print("\nAdicionar novo e-mail para monitoramento")
    print("-" * 60)
    
    # Solicitar informa√ß√µes b√°sicas do email
    email = input("Digite o endere√ßo de e-mail: ").strip()
    
    if not email:
        print("Opera√ß√£o cancelada.")
        return
        
    if not is_valid_email(email):
        print("‚ùå Formato de e-mail inv√°lido!")
        return
    
    # Detectar servidor automaticamente ou pedir para escolher
    server_info = detect_server_from_email(email)
    if not server_info:
        print("\nN√£o foi poss√≠vel detectar o servidor automaticamente.")
        server_info = choose_imap_server()
        if not server_info:
            print("Opera√ß√£o cancelada.")
            return
    else:
        print(f"\nDetectado servidor: {server_info['name']} ({server_info['server']}:{server_info['port']})")
        print(server_info['instructions'])
        
        # Confirmar se quer usar o servidor detectado
        confirm = input("\nUsar este servidor? (s/n): ").lower()
        if confirm != 's':
            server_info = choose_imap_server()
            if not server_info:
                print("Opera√ß√£o cancelada.")
                return
    
    # Solicitar senha
    password = input(f"\nSenha para {email}: ")
    if not password:
        print("Opera√ß√£o cancelada.")
        return
    
    # Testar conex√£o
    print(f"\nTestando conex√£o para {email}...")
    success, msg = test_email_connection(
        server_info['server'], 
        server_info['port'], 
        email, 
        password
    )
    
    if not success:
        retry = input("\nO teste de conex√£o falhou. Deseja salvar mesmo assim? (s/n): ").lower()
        if retry != 's':
            print("Opera√ß√£o cancelada.")
            return
    
    # Op√ß√µes avan√ßadas
    use_custom_telegram = input("\nDeseja configurar notifica√ß√µes personalizadas do Telegram? (s/n): ").lower()
    custom_chat_id = ""
    custom_token = ""
    
    if use_custom_telegram == 's':
        custom_chat_id = input("Chat ID espec√≠fico para este e-mail (deixe vazio para usar o global): ").strip()
        if custom_chat_id and not is_valid_chat_id(custom_chat_id):
            print("‚ùå Chat ID inv√°lido! Deve ser um n√∫mero inteiro.")
            custom_chat_id = ""
        
        custom_token = input("Token espec√≠fico para este e-mail (deixe vazio para usar o global): ").strip()
    
    # Determinar qual se√ß√£o usar
    section_name = f"IMAP_{email}"
    
    # Verificar se j√° existe
    if section_name in config:
        overwrite = input(f"\nO e-mail {email} j√° existe na configura√ß√£o. Deseja sobrescrever? (s/n): ").lower()
        if overwrite != 's':
            print("Opera√ß√£o cancelada.")
            return
    
    # Criar se√ß√£o
    config[section_name] = {
        'server': server_info['server'],
        'port': str(server_info['port']),
        'username': email,
        'password': password,
        'is_active': 'True'
    }
    
    # Adicionar configura√ß√µes personalizadas do Telegram, se fornecidas
    if custom_chat_id:
        config[section_name]['telegram_chat_id'] = custom_chat_id
    if custom_token:
        config[section_name]['telegram_token'] = custom_token
    
    # Salvar configura√ß√£o
    save_config(config)
    update_env_file(config)
    
    print(f"\n‚úÖ E-mail {email} adicionado com sucesso ao monitoramento!")
    return True

def remove_email(config: configparser.ConfigParser):
    """Remove um e-mail do monitoramento"""
    print("\nRemover e-mail do monitoramento")
    print("-" * 60)
    
    # Lista todos os e-mails dispon√≠veis
    email_sections = []
    for section in config.sections():
        if section.startswith('IMAP_') and 'username' in config[section]:
            email_sections.append((section, config[section]['username']))
    
    if not email_sections:
        print("Nenhum e-mail configurado para remo√ß√£o!")
        return
    
    print("E-mails dispon√≠veis para remo√ß√£o:")
    for i, (section, email) in enumerate(email_sections, 1):
        print(f"{i}. {email} ({section})")
    
    try:
        choice = int(input("\nEscolha o e-mail a ser removido (0 para cancelar): "))
        if choice == 0:
            print("Opera√ß√£o cancelada.")
            return
        
        if 1 <= choice <= len(email_sections):
            section_to_remove = email_sections[choice - 1][0]
            email_to_remove = email_sections[choice - 1][1]
            
            # Confirmar remo√ß√£o
            confirm = input(f"Tem certeza que deseja remover {email_to_remove}? (s/n): ").lower()
            if confirm == 's':
                config.remove_section(section_to_remove)
                save_config(config)
                update_env_file(config)
                print(f"‚úÖ E-mail {email_to_remove} removido com sucesso!")
            else:
                print("Opera√ß√£o cancelada.")
        else:
            print("Op√ß√£o inv√°lida!")
    except ValueError:
        print("Entrada inv√°lida!")
    except Exception as e:
        logger.error(f"Erro ao remover e-mail: {str(e)}")
        print(f"Ocorreu um erro: {str(e)}")

def edit_email(config: configparser.ConfigParser):
    """Edita as configura√ß√µes de um e-mail monitorado"""
    print("\nEditar configura√ß√µes de e-mail")
    print("-" * 60)
    
    # Lista todos os e-mails dispon√≠veis
    email_sections = []
    for section in config.sections():
        if section.startswith('IMAP_') and 'username' in config[section]:
            email_sections.append((section, config[section]['username']))
    
    if not email_sections:
        print("Nenhum e-mail configurado para edi√ß√£o!")
        return
    
    print("E-mails dispon√≠veis para edi√ß√£o:")
    for i, (section, email) in enumerate(email_sections, 1):
        print(f"{i}. {email} ({section})")
    
    try:
        choice = int(input("\nEscolha o e-mail a ser editado (0 para cancelar): "))
        if choice == 0:
            print("Opera√ß√£o cancelada.")
            return
        
        if 1 <= choice <= len(email_sections):
            section = email_sections[choice - 1][0]
            email = email_sections[choice - 1][1]
            
            print(f"\nEditando configura√ß√µes para: {email}")
            print("-" * 60)
            
            # Mostrar op√ß√µes de edi√ß√£o
            print("Op√ß√µes de edi√ß√£o:")
            print("1. Mudar servidor/porta")
            print("2. Mudar senha")
            print("3. Ativar/desativar monitoramento")
            print("4. Configurar notifica√ß√µes personalizadas")
            print("5. Voltar")
            
            edit_choice = int(input("\nEscolha uma op√ß√£o: "))
            
            if edit_choice == 1:
                # Editar servidor e porta
                print("\nMudando servidor/porta:")
                new_server = input(f"Novo servidor [{config[section]['server']}]: ") or config[section]['server']
                try:
                    new_port = int(input(f"Nova porta [{config[section]['port']}]: ") or config[section]['port'])
                    config[section]['server'] = new_server
                    config[section]['port'] = str(new_port)
                    save_config(config)
                    update_env_file(config)
                    print("‚úÖ Servidor/porta atualizados com sucesso!")
                except ValueError:
                    print("‚ùå Porta inv√°lida! Opera√ß√£o cancelada.")
            
            elif edit_choice == 2:
                # Editar senha
                print("\nMudando senha:")
                new_password = input("Nova senha: ")
                if new_password:
                    # Testar conex√£o com a nova senha
                    print("\nTestando nova senha...")
                    success, msg = test_email_connection(
                        config[section]['server'],
                        int(config[section]['port']),
                        config[section]['username'],
                        new_password
                    )
                    
                    if success:
                        config[section]['password'] = new_password
                        save_config(config)
                        update_env_file(config)
                        print("‚úÖ Senha atualizada com sucesso!")
                    else:
                        print(f"‚ùå Falha no teste de conex√£o: {msg}")
                        retry = input("Deseja salvar a senha mesmo assim? (s/n): ").lower()
                        if retry == 's':
                            config[section]['password'] = new_password
                            save_config(config)
                            update_env_file(config)
                            print("‚úÖ Senha atualizada (mas o teste de conex√£o falhou)!")
                else:
                    print("Opera√ß√£o cancelada.")
            
            elif edit_choice == 3:
                # Ativar/desativar
                is_active = config[section].getboolean('is_active', True)
                print(f"\nStatus atual: {'Ativo' if is_active else 'Inativo'}")
                
                new_status = input("Deseja ativar ou desativar? (a/d): ").lower()
                if new_status == 'a':
                    config[section]['is_active'] = 'True'
                    save_config(config)
                    update_env_file(config)
                    print("‚úÖ E-mail ativado com sucesso!")
                elif new_status == 'd':
                    config[section]['is_active'] = 'False'
                    save_config(config)
                    update_env_file(config)
                    print("‚úÖ E-mail desativado com sucesso!")
                else:
                    print("Op√ß√£o inv√°lida. Opera√ß√£o cancelada.")
            
            elif edit_choice == 4:
                # Configurar notifica√ß√µes personalizadas
                print("\nConfigurando notifica√ß√µes personalizadas:")
                
                current_chat_id = config[section].get('telegram_chat_id', '')
                current_token = config[section].get('telegram_token', '')
                
                print(f"Chat ID atual: {current_chat_id or 'Usando configura√ß√£o global'}")
                print(f"Token atual: {'Personalizado' if current_token else 'Usando configura√ß√£o global'}")
                
                new_chat_id = input("Novo Chat ID (deixe vazio para usar global): ")
                if new_chat_id:
                    if is_valid_chat_id(new_chat_id):
                        config[section]['telegram_chat_id'] = new_chat_id
                    else:
                        print("‚ùå Chat ID inv√°lido! Deve ser um n√∫mero inteiro.")
                        new_chat_id = ""
                
                new_token = input("Novo Token (deixe vazio para usar global): ")
                if new_token:
                    config[section]['telegram_token'] = new_token
                
                if new_chat_id or new_token:
                    save_config(config)
                    update_env_file(config)
                    print("‚úÖ Configura√ß√µes de notifica√ß√£o atualizadas!")
                else:
                    print("Nenhuma altera√ß√£o realizada.")
            
            elif edit_choice == 5:
                print("Voltando ao menu principal...")
                return
            else:
                print("Op√ß√£o inv√°lida.")
        else:
            print("Op√ß√£o inv√°lida!")
    except ValueError:
        print("Entrada inv√°lida!")
    except Exception as e:
        logger.error(f"Erro ao editar e-mail: {str(e)}")
        print(f"Ocorreu um erro: {str(e)}")

def setup_telegram(config: configparser.ConfigParser):
    """Configura ou atualiza as configura√ß√µes do Telegram"""
    print("\nConfigura√ß√£o do Telegram")
    print("-" * 60)
    
    # Verifica se a se√ß√£o TELEGRAM existe
    if 'TELEGRAM' not in config:
        config['TELEGRAM'] = {}
        
    # Mostrar configura√ß√£o atual
    current_token = config['TELEGRAM'].get('token', '')
    current_chat_id = config['TELEGRAM'].get('chat_id', '')
    
    masked_token = "‚Ä¢‚Ä¢‚Ä¢‚Ä¢" + current_token[-4:] if current_token and len(current_token) > 4 else "n√£o configurado"
    print(f"Token atual: {masked_token}")
    print(f"Chat ID atual: {current_chat_id or 'n√£o configurado'}")
    
    print("\nEscolha o que deseja configurar:")
    print("1. Token do Bot")
    print("2. Chat ID")
    print("3. Ambos")
    print("4. Verificar configura√ß√£o atual")
    print("5. Voltar")
    
    try:
        choice = int(input("\nEscolha uma op√ß√£o: "))
        
        if choice == 1:
            # Configurar apenas o token
            new_token = input("\nDigite o novo token do bot (gerado pelo BotFather): ")
            if new_token:
                config['TELEGRAM']['token'] = new_token.strip()
                save_config(config)
                update_env_file(config)
                print("‚úÖ Token atualizado com sucesso!")
            else:
                print("Opera√ß√£o cancelada.")
                
        elif choice == 2:
            # Configurar apenas o Chat ID
            new_chat_id = input("\nDigite o novo Chat ID: ")
            if new_chat_id and is_valid_chat_id(new_chat_id):
                config['TELEGRAM']['chat_id'] = new_chat_id.strip()
                save_config(config)
                update_env_file(config)
                print("‚úÖ Chat ID atualizado com sucesso!")
            elif new_chat_id:
                print("‚ùå Chat ID inv√°lido! Deve ser um n√∫mero inteiro.")
            else:
                print("Opera√ß√£o cancelada.")
                
        elif choice == 3:
            # Configurar ambos
            new_token = input("\nDigite o novo token do bot (gerado pelo BotFather): ")
            new_chat_id = input("Digite o novo Chat ID: ")
            
            if new_token and new_chat_id:
                if is_valid_chat_id(new_chat_id):
                    config['TELEGRAM']['token'] = new_token.strip()
                    config['TELEGRAM']['chat_id'] = new_chat_id.strip()
                    save_config(config)
                    update_env_file(config)
                    print("‚úÖ Configura√ß√µes atualizadas com sucesso!")
                    
                    # Oferecer teste imediato
                    test_now = input("\nDeseja testar as novas configura√ß√µes agora? (s/n): ").lower()
                    if test_now == 's':
                        test_telegram_notifications(config)
                else:
                    print("‚ùå Chat ID inv√°lido! Deve ser um n√∫mero inteiro.")
            else:
                print("Opera√ß√£o cancelada.")
                
        elif choice == 4:
            # Apenas verificar a configura√ß√£o atual
            if current_token and current_chat_id:
                print("\n‚úÖ Configura√ß√£o do Telegram est√° completa.")
                
                # Oferecer teste
                test_now = input("\nDeseja testar a configura√ß√£o atual? (s/n): ").lower()
                if test_now == 's':
                    test_telegram_notifications(config)
            else:
                print("\n‚ùå Configura√ß√£o do Telegram est√° incompleta!")
                missing = []
                if not current_token:
                    missing.append("Token")
                if not current_chat_id:
                    missing.append("Chat ID")
                print(f"Itens faltantes: {', '.join(missing)}")
                
        elif choice == 5:
            # Voltar ao menu principal
            print("Voltando ao menu principal...")
            return
        
        else:
            print("Op√ß√£o inv√°lida!")
            
    except ValueError:
        print("Entrada inv√°lida!")
    except Exception as e:
        logger.error(f"Erro ao configurar Telegram: {str(e)}")
        print(f"Ocorreu um erro: {str(e)}")

def migrate_old_format(config: configparser.ConfigParser) -> bool:
    """Migra formatos antigos de configura√ß√£o para o novo formato IMAP_*"""
    migrated = False
    
    # Verificar se existem se√ß√µes antigas com formatos n√£o padronizados
    old_email_sections = []
    for section in config.sections():
        # Procura por se√ß√µes que n√£o come√ßam com IMAP_ mas t√™m par√¢metros de email
        if not section.startswith('IMAP_') and section not in ['TELEGRAM'] and 'server' in config[section] and 'username' in config[section]:
            old_email_sections.append(section)
    
    # Migrar cada se√ß√£o antiga para o novo formato
    for old_section in old_email_sections:
        email = config[old_section]['username']
        new_section = f"IMAP_{email}"
        
        # Criar nova se√ß√£o
        if new_section not in config:
            config[new_section] = {}
            
            # Copiar todos os par√¢metros
            for key in config[old_section]:
                config[new_section][key] = config[old_section][key]
            
            # Remover se√ß√£o antiga
            config.remove_section(old_section)
            migrated = True
            logger.info(f"Migrada configura√ß√£o de email {email} para o novo formato")
    
    # Verificar se j√° existem as se√ß√µes IMAP_PRIMARY e IMAP_SECONDARY
    # Se n√£o, criar a partir de emails existentes
    if 'IMAP_PRIMARY' not in config:
        # Procurar o primeiro email dispon√≠vel para usar como prim√°rio
        for section in config.sections():
            if section.startswith('IMAP_') and 'username' in config[section] and section not in ['IMAP_PRIMARY', 'IMAP_SECONDARY']:
                # Criar IMAP_PRIMARY
                config['IMAP_PRIMARY'] = {}
                for key in config[section]:
                    config['IMAP_PRIMARY'][key] = config[section][key]
                
                # N√£o remove a se√ß√£o original, apenas copia para IMAP_PRIMARY
                migrated = True
                logger.info(f"Criada se√ß√£o IMAP_PRIMARY a partir de {section}")
                break
    
    # Se houver migra√ß√£o, salvar as altera√ß√µes
    if migrated:
        save_config(config)
    
    return migrated

def test_telegram_notifications(config: configparser.ConfigParser):
    """Testa o envio de notifica√ß√µes via Telegram"""
    print("\nTeste de Notifica√ß√µes do Telegram")
    print("-" * 60)
    
    if 'TELEGRAM' not in config or not config['TELEGRAM'].get('token') or not config['TELEGRAM'].get('chat_id'):
        print("‚ùå Configura√ß√£o do Telegram incompleta! Verifique as configura√ß√µes.")
        return False
    
    token = config['TELEGRAM'].get('token')
    chat_id = config['TELEGRAM'].get('chat_id')
    
    print(f"Token: {'‚Ä¢‚Ä¢‚Ä¢‚Ä¢' + token[-4:] if token else 'n√£o configurado'}")
    print(f"Chat ID: {chat_id}")
    
    # Teste 1: Mensagem simples
    print("\nEnviando mensagem de teste...")
    current_time = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
    message = (
        "üß™ *Teste do WegNots*\n\n"
        f"Este √© um teste de notifica√ß√£o do sistema\\.\n"
        f"‚è∞ {escape_markdown(current_time)}"
    )
    
    if send_telegram_notification(config, message):
        print("‚úÖ Mensagem de teste enviada com sucesso!")
    else:
        print("‚ùå Falha ao enviar mensagem de teste!")
        return False
    
    # Teste 2: Notifica√ß√£o de inicializa√ß√£o
    print("\nSimulando notifica√ß√£o de inicializa√ß√£o...")
    if send_system_startup_notification(config):
        print("‚úÖ Notifica√ß√£o de inicializa√ß√£o enviada com sucesso!")
    else:
        print("‚ùå Falha ao enviar notifica√ß√£o de inicializa√ß√£o!")
        return False
    
    # Teste 3: Notifica√ß√£o de encerramento
    print("\nSimulando notifica√ß√£o de encerramento...")
    if send_system_shutdown_notification(config):
        print("‚úÖ Notifica√ß√£o de encerramento enviada com sucesso!")
    else:
        print("‚ùå Falha ao enviar notifica√ß√£o de encerramento!")
        return False
    
    print("\n‚úÖ Todos os testes de notifica√ß√£o foram bem-sucedidos!")
    return True

def main():
    """Fun√ß√£o principal do gerenciador de configura√ß√£o"""
    config = load_config()
    
    # Verifica e migra formatos antigos
    migrated = migrate_old_format(config)
    if migrated:
        print("\nAs configura√ß√µes foram migradas para o novo formato!")
        input("Pressione ENTER para continuar...")
    
    send_system_startup_notification(config)
    
    try:
        while True:
            print("\nGerenciador de Configura√ß√£o do Monitor")
            print("=" * 60)
            print("1. Listar e-mails monitorados")
            print("2. Adicionar novo e-mail")
            print("3. Remover e-mail")
            print("4. Editar configura√ß√µes de e-mail")
            print("5. Configurar Telegram")
            print("6. Testar notifica√ß√µes do Telegram")
            print("7. Sair")
            
            try:
                choice = int(input("\nEscolha uma op√ß√£o: "))
                
                if choice == 1:
                    list_monitored_emails(config)
                elif choice == 2:
                    add_email(config)
                elif choice == 3:
                    remove_email(config)
                elif choice == 4:
                    edit_email(config)
                elif choice == 5:
                    setup_telegram(config)
                elif choice == 6:
                    test_telegram_notifications(config)
                elif choice == 7:
                    print("\nSaindo...")
                    break
                else:
                    print("Op√ß√£o inv√°lida!")
            except ValueError:
                print("Entrada inv√°lida!")
            except Exception as e:
                logger.error(f"Erro n√£o tratado: {str(e)}")
                print(f"Ocorreu um erro: {str(e)}")
            
            input("\nPressione ENTER para continuar...")
    finally:
        send_system_shutdown_notification(config)

if __name__ == "__main__":
    main()